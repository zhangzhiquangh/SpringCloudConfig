==和equals方法
Java程序中测试两个变量是否相等有两种方式：一种是利用==运算符，另一种是利用equals()方法。
当使用==来判断两个变量是否相等时
如果两个变量都是基本类型变量，且都是数值类型（不一定要求数据类型严格相同），则只要两个变量的值相等，就将返回true。
但对于两个引用类型变量，只有它们指向同一个对象时，==判断才会返回true。==不可用于比较类型上没有父子关系的两个对象。
equals方法
但在很多时候，程序判断两个引用变量是否相等时，也希望有一种类似于“值相等”的判断规则，并不严格要求两个引用变量指向同一个对象。
equals()方法是Object类提供的一个实例方法，因此所有引用变量都可调用该方法来判断是否与其他引用变量相等。

HashSet类
HashSet是Set接口的典型实现，大多数时候使用Set集合时就是使用这个实现类。HashSet按Hash算法来存储集合中的元素，因此具有很好的存取和查找性能。
HashSet具有以下特点。
不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。
HashSet不是同步的，如果多个线程同时访问一个HashSet，假设有两个或者两个以上线程同时修改了HashSet集合时，则必须通过代码来保证其两步。
集合元素值可以是null。
当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据该hashCode值决定该对象在HashSet中的存储位置。如果有两个元素通过equals()方法比较
返回true，但它们的hashCode()方法返回值不相等，HashSet将会把它们存储在不同的位置，依然可以添加成功。
也就是说，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法返回值也相等。

LinkedHashSet类
HashSet还有一个子类LinkedHashSet，LinkedHashSet集合也是根据元素的hashCode值决定元素的存储位置，但它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。也就是
说，当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素。
LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能，但在迭代访问Set里的全部元素时将有很好的性能，因此它以链表来维护内部顺序

TreeSet类
TreeSet是SortedSet接口的实现类，正如SortedSet名字所暗示的，TreeSet可以确保集合元素处于排序状态。
TreeSet并不是根据元素的插入顺序进行排序的，而是根据元素实际值的大小来进行排序的。
与HashSet集合采用hash算法来决定元素的存储位置不同，TreeSet采用红黑树的数据结构来存储集合元素。TreeSet支持两种排序方法：自然排序和定制排序，默认采用自然排序

EnumSet类
EnumSet是一个专门为枚举类设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式或隐式地指定。EnumSet的集合元素也是有序的，
EnumSet以枚举值在Enum类内的定义顺序来决定集合元素的顺序。
EnumSet在内部以位向量的形式存储，这种存储形式非常紧凑、高效，因此EnumSet对象占用内存很小，而且运行效率很好。尤其是进行批量操作时，如果参数也是EnumSet集合，则该批量操作的执行
速度也非常快。

各Set实现类的性能分析
HashSet性能比TreeSet好（特别是最常用的添加、查询元素等操作），因为TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的Set时，才应该使用TreeSet，否则都应该使用HashSet。
对于变通插入、删除操作，LinkedHashSet比HashSet要略微慢一点，这是由维护链表所带来的额外开销造成的，但由于有了链表，遍历LinkedHashSet会更快。
EnumSet是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素。
必须指出的是，Set的三个实现类HashSet、TreeSet和EnumSet都是线程不安全的。

ArrayList和Vector实现类
都是List类的典型实现，但Vector相对ArrayList古老
两者的主要区别
ArrayList不是线程安全的，Vector是线程安全的，Vector的性能比ArrayList低

Queue集合
Queue用于模拟队列这种数据结构，队列通常是指“先进先出”的容器

PriorityQueue实现类
PriorityQueue是一个比较标准的队列实现类。PriorityQueue保存队列元素的顺序并不是按加入队列的顺序，而是按队列元素的大小进行重新排序。

Deque接口与ArrayDeque实现类
Deque接口是Queue接口的子接口，它代表一个双端队列，Deque接口里定义了一些双端队列的方法，这些方法允许从两端来操作队列的元素。

LinkedList实现类
LinkedList类是List接口的实现类，还实现了Deque接口

各种线性表的性能分析
Java提供的List就是一个线性表接口，而ArrayList、LinkedList又是线性表的两种典型实现
基于数组的线性表（随机访问性能最好）和基于链的线性表（执行插入、删除操作时有较好的性能）。
ArrayList性能比LinkedList的性能要好

Java8增强的Map集合
Map用于保存具有映射关系的数据
如果把Map里的所有key放在一起来看，它们就组成了一个Set集合

Java8改进的HashMap和Hashtable实现类
Hashtable是一个古老的Map实现类
HashMap和Hashtable存在两点典型区别
Hashtable是一个线程安全的Map实现，HashMap是线程不安全的实现，所以HashMap比Hashtable的性能高一点
Hashtable不允许使用null作为key和value，HashMap可以使用null作为key和value

LinkedHashMap实现类
LinkedHashMap也使用双向链表来维护key-value对我次序，性能略低于HashMap

使用Properties读写属性文件
Properties类是Hashtable类的子类，该对象在处理属性文件时特别方便

SortedMap接口和TreeMap实现类
